# おすすめランキング算出方法

## 概要

Scrap-Boardのおすすめランキングは、ユーザーのブックマーク履歴から学習したプロファイルを基に、各記事に対して個別のスコアを算出し、順位付けを行います。このドキュメントでは、その詳細なアルゴリズムと実装について説明します。

## スコア算出の基本構造

### 総合スコアの計算式

各記事の総合スコアは、**4つのコンポーネント**を重み付けして合成します。

```
総合スコア = 
  類似度 × 50% (similarity_weight: 0.5)
  + カテゴリスコア × 25% (category_weight: 0.25)
  + ドメインスコア × 15% (domain_weight: 0.15)
  + 新鮮度 × 10% (freshness_weight: 0.1)
```

すべてのコンポーネントは 0.0〜1.0 の範囲に正規化され、最終的な総合スコアも 0.0〜1.0 の範囲になります。

## 各コンポーネントの詳細

### 1. 類似度 (Similarity) - 50%

**目的**: 記事の内容がユーザーの興味関心とどれだけ一致しているかを測定

**計算方法**:
- ユーザーのブックマークした記事の埋め込みベクトルの平均（プロファイル埋め込み）を計算
- 対象記事の埋め込みベクトルとのコサイン類似度を算出
- 値の範囲: 0.0〜1.0

**実装詳細**:
```python
def _compute_similarity(profile_embedding, doc_embedding):
    # ベクトル長を揃える
    length = min(len(profile_embedding), len(doc_embedding))
    vec1 = profile_embedding[:length]
    vec2 = doc_embedding[:length]
    
    # コサイン類似度を計算
    return cosine_similarity(vec1, vec2)
```

**説明文への反映**:
- スコア ≥ 0.65: 「内容が最近の関心と強く一致しています。」
- スコア ≥ 0.35: 「内容があなたの興味とおおむね合致しています。」
- スコア < 0.35: 「内容の一致度はまだ低めです。」

### 2. カテゴリスコア (Category) - 25%

**目的**: ユーザーが好んで読むカテゴリの記事を優先

**計算方法**:
- 記事のプライマリカテゴリ（例: テック/AI、ビジネス等）を取得
- プロファイルに保存されているカテゴリ重み（`category_weights`）から該当カテゴリの重みを取得
- 値の範囲: 0.0〜1.0

**カテゴリ重みの更新**:
- ブックマーク追加時にそのカテゴリの重みを増加
- ブックマーク削除時にそのカテゴリの重みを減少
- 全体の合計が1.0になるよう正規化

**説明文への反映**:
- スコア ≥ 0.35: 「{カテゴリ} 分野の記事をよく読んでいるため優先しました。」
- スコア ≤ 0.1: 「{カテゴリ} 分野はこれから学習していきます。」

### 3. ドメインスコア (Domain) - 15%

**目的**: ユーザーが信頼する情報源からの記事を優先

**計算方法**:
- 記事のドメイン（例: zenn.dev、gigazine.net等）を取得
- プロファイルに保存されているドメイン重み（`domain_weights`）から該当ドメインの重みを取得
- 値の範囲: 0.0〜1.0

**ドメイン重みの更新**:
- カテゴリスコアと同様に、ブックマーク操作に応じて更新
- 全体の合計が1.0になるよう正規化

**説明文への反映**:
- スコア ≥ 0.35: 「{ドメイン} のコンテンツを頻繁に保存している傾向があります。」
- スコア ≤ 0.1: 「{ドメイン} からの情報はまだ少なめです。」

### 4. 新鮮度 (Freshness) - 10%

**目的**: 新しい記事を優先的に表示

**計算方法**:
- 記事の公開日時（`published_at`、`created_at`、`updated_at`、`fetched_at`の順で確認）を取得
- 現在時刻からの経過時間を計算
- 指数関数的な減衰を適用: `exp(-経過時間(h) / 72)`
- 値の範囲: 0.0〜1.0

**減衰の特性**:
- 72時間（3日）が半減期
- 新規記事（0時間）: スコア = 1.0
- 3日経過: スコア ≈ 0.37
- 1週間経過: スコア ≈ 0.15
- 日時情報がない場合: デフォルト値 0.2

**説明文への反映**:
- スコア ≥ 0.5: 「新着の記事なので早めにチェックすると良いでしょう。」
- スコア < 0.5: 「更新から少し時間が経っています。」

## ランキングの決定

### ソートキー

記事は以下の優先順位でソートされます:

1. **総合スコア（降順）**: 高いスコアの記事が上位
2. **新鮮度ソートキー（昇順）**: 同点の場合、より新しい記事を優先
3. **ドキュメントID（昇順）**: 完全に同一条件の場合、IDで安定ソート

### ランク付与

ソート後、1位から順にランク番号を付与します。このランクは記事カードに表示され、ユーザーに順位を伝えます。

## コールドスタート対応

### コールドスタートとは

ブックマークが少ない初期段階では、プロファイルデータが不十分なため、スコアの精度が低くなります。この状態を「コールドスタート」と呼びます。

### 閾値

- デフォルト: `DEFAULT_COLD_START_THRESHOLD = 1`
- ブックマーク数がこの閾値未満の場合、コールドスタート状態と判定

### コールドスタート時の挙動

- `cold_start` フラグが `True` に設定
- 説明文に「ブックマークを追加すると、おすすめの精度が向上します。」を追加
- スコア計算自体は通常通り実行（利用可能なデータのみ使用）

### 脱出方法

ブックマークを追加して閾値以上になると、自動的にコールドスタート状態から脱出します。

## 説明文の生成

### ExplanationPresenter

各記事のスコアを分析し、日本語で分かりやすい説明文を生成します。

**閾値設定**:
- `strong_threshold: 0.65` - 強い一致と判定する閾値
- `medium_threshold: 0.35` - 中程度の一致と判定する閾値
- `fresh_threshold: 0.5` - 新鮮と判定する閾値

**説明文の構成**:
1. コールドスタート状態の通知（該当時のみ）
2. 類似度に基づく内容の一致度
3. カテゴリに関する情報
4. ドメインに関する情報
5. 新鮮度に関する情報
6. 追加のノート（該当時のみ）
7. 今後の精度向上に関するメッセージ（コールドスタート時）

**結合**:
- 各要素を " / " で結合してワンライン形式で表示

## プロファイルの更新

### 更新タイミング

- **ブックマーク追加時**: プロファイルを更新し、パーソナライゼーションスコアを再計算
- **ブックマーク削除時**: プロファイルを更新し、パーソナライゼーションスコアを再計算
- **バックグラウンドジョブ**: 定期的にスコアをリフレッシュ（実装予定）

### PreferenceProfileService

プロファイルの管理を担当するサービスクラス:

- `update_profile()`: ブックマーク操作に応じてプロファイルを更新
- `get_profile()`: 現在のプロファイルを取得
- カテゴリ重み、ドメイン重み、埋め込みベクトルの計算と正規化

## 実装クラス

### PersonalizedRankingService

**主要メソッド**:
- `score_documents(documents, profile)`: ドキュメント群に対してスコアを算出
- `_compute_similarity()`: 類似度を計算
- `_compute_freshness()`: 新鮮度を計算
- `_compose_score()`: 各コンポーネントを合成して総合スコアを算出

**初期化パラメータ**:
```python
PersonalizedRankingService(
    similarity_weight=0.5,      # 類似度の重み
    category_weight=0.25,       # カテゴリの重み
    domain_weight=0.15,         # ドメインの重み
    freshness_weight=0.1,       # 新鮮度の重み
    now_provider=datetime.utcnow,  # 現在時刻の取得関数
    explanation_presenter=ExplanationPresenter()  # 説明文生成
)
```

## パフォーマンス最適化

### データベース設計

- `personalized_scores` テーブルに計算済みスコアをキャッシュ
- `computed_at` カラムで最終計算時刻を記録
- インデックスを活用して高速検索

### 計算の効率化

- 埋め込みベクトルの次元数を最小限に（両方のベクトルの短い方に合わせる）
- ベクトル計算ライブラリ（NumPy等）を活用
- 不要な再計算を避ける

### スケーラビリティ

- 現在はゲストユーザー1人前提
- 将来のマルチユーザー対応に向けて、`user_id` でパーティション可能な設計

## テストとデバッグ

### スコアの検証

```bash
# API経由でパーソナライゼーションスコアを確認
curl -s 'http://localhost:8000/api/documents/personalized?user_id=guest' | jq '.scores[] | {document_id, score, rank, explanation}'
```

### ログ出力

重要な計算過程はログに記録:
- 類似度計算の失敗
- 埋め込みベクトルの欠損
- スコア計算のエラー

## 今後の改善予定

1. **機械学習モデルの導入**: ルールベースから学習ベースへ
2. **時系列パターンの学習**: 曜日や時間帯による嗜好の変化を考慮
3. **コンテキスト認識**: 最近の閲覧履歴に基づくセッション内での適応
4. **A/Bテスト**: 重み付けの最適化
5. **フィードバックループ**: クリック率や滞在時間を学習に活用

## 参考実装

- **実装ファイル**: `app/services/personalized_ranking.py`
- **プロファイル管理**: `app/services/preference_profile.py`
- **モデル定義**: `app/services/personalization_models.py`
- **類似度計算**: `app/services/similarity.py`

## 関連ドキュメント

- [ゲストユーザー仕様](./guest-user-specification.md)
- [要件定義](./requirements.md)
- [技術仕様](./tech.md)
