{
  "id": "snapshot_1759559015474_jz2wo3f8l",
  "approvalId": "approval_1759559015462_s6hvd194j",
  "approvalTitle": "SpeakerDeck Feed Support - Design",
  "version": 1,
  "timestamp": "2025-10-04T06:23:35.474Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design: SpeakerDeck Feed Support\n\n## 概要\nSpeakerDeckのRSS/Atomフィードからプレゼンテーションを自動取得し、PDFを永続保存して記事カードからダウンロード可能にする機能の技術設計です。既存のフィード取得メカニズムとingestionパイプラインを拡張し、新しいPDF管理機能を追加します。\n\n## アーキテクチャ\n\n### 全体フロー\n```\n┌─────────────────────┐\n│  Scheduler (cron)   │\n└──────────┬──────────┘\n           │\n           v\n┌─────────────────────┐\n│ trigger_fetch_for_  │\n│   source()          │\n└──────────┬──────────┘\n           │\n           v\n┌─────────────────────┐\n│ _fetch_speakerdeck_ │\n│   items()           │ ← feedparser (RSS/Atom)\n└──────────┬──────────┘\n           │\n           v (各エントリ)\n┌─────────────────────┐\n│ _insert_document_   │\n│   from_url()        │\n└──────────┬──────────┘\n           │\n           ├─→ extractor.extract_from_url()\n           │\n           ├─→ [SpeakerDeck検出]\n           │      │\n           │      v\n           │   ┌─────────────────────┐\n           │   │ SpeakerDeckHandler  │\n           │   │ - get_pdf_url()     │\n           │   │ - download_pdf()    │\n           │   └─────────────────────┘\n           │      │\n           │      v\n           │   data/assets/pdfs/speakerdeck/{doc_id}.pdf\n           │\n           v\n    ┌──────────────┐\n    │ DB: documents│\n    │ + pdf_path   │\n    └──────────────┘\n           │\n           v\n    ┌──────────────┐\n    │ UI: Card     │\n    │ + DL button  │\n    └──────────────┘\n```\n\n## コンポーネント設計\n\n### 1. データベーススキーマ拡張\n\n#### マイグレーション: `007_add_pdf_support.sql`\n```sql\n-- Add pdf_path column to documents table\nALTER TABLE documents ADD COLUMN pdf_path TEXT;\n\n-- Create index for faster PDF queries\nCREATE INDEX IF NOT EXISTS idx_documents_pdf_path ON documents(pdf_path) WHERE pdf_path IS NOT NULL;\n```\n\n**理由**: \n- `pdf_path`: ローカルに保存されたPDFファイルへの相対パス（例: `assets/pdfs/speakerdeck/abc123.pdf`）\n- NULL許可により既存ドキュメントへの後方互換性を維持\n- 部分インデックスでPDFを持つドキュメントの検索を高速化\n\n### 2. SpeakerDeckフィード取得\n\n#### `app/services/ingest_worker.py` に追加\n\n```python\ndef _fetch_speakerdeck_items(config: Dict[str, Any]):\n    \"\"\"Fetch items from SpeakerDeck RSS/Atom feed.\n    \n    Config keys:\n    - `username`: SpeakerDeck username (generates .rss URL)\n    - `url`: Direct feed URL (.rss or .atom)\n    - `per_page`: Max items to fetch (default: 20)\n    - `format`: 'rss' or 'atom' (default: 'rss')\n    \n    Returns:\n        List of dicts with keys: link, title, published, summary\n    \"\"\"\n    items = []\n    per_page = config.get(\"per_page\", 20)\n    \n    try:\n        import feedparser\n        \n        # Generate feed URL from username or use direct URL\n        if config.get(\"username\"):\n            feed_format = config.get(\"format\", \"rss\")\n            username = config[\"username\"]\n            url = f\"https://speakerdeck.com/{username}.{feed_format}\"\n        elif config.get(\"url\"):\n            url = config[\"url\"]\n        else:\n            logger.warning(\"SpeakerDeck source missing username or url\")\n            return items\n        \n        logger.info(f\"Fetching SpeakerDeck feed: {url}\")\n        parsed = feedparser.parse(url)\n        \n        for e in parsed.entries[:per_page]:\n            items.append({\n                \"link\": e.get(\"link\"),\n                \"title\": e.get(\"title\"),\n                \"published\": e.get(\"published\"),\n                \"summary\": e.get(\"summary\", \"\"),\n            })\n        \n        logger.info(f\"Fetched {len(items)} items from SpeakerDeck\")\n    \n    except ModuleNotFoundError:\n        logger.warning(\"feedparser not installed; SpeakerDeck RSS fetch skipped\")\n    except Exception as e:\n        logger.error(f\"SpeakerDeck fetch error: {e}\")\n    \n    return items\n```\n\n#### `trigger_fetch_for_source()` への統合\n\n既存の関数に `speakerdeck` タイプのハンドリングを追加：\n\n```python\ndef trigger_fetch_for_source(source_id: int):\n    # ... 既存コード ...\n    \n    if source_type == \"qiita\":\n        items = _fetch_qiita_items(config)\n    elif source_type == \"hatena\":\n        items = _fetch_hatena_items(config)\n    elif source_type == \"rss\":\n        items = _fetch_rss_items(config)\n    elif source_type == \"speakerdeck\":  # 追加\n        items = _fetch_speakerdeck_items(config)\n    else:\n        logger.warning(f\"Unknown source type: {source_type}\")\n        return\n    \n    # ... 残りの処理 ...\n```\n\n**設計判断**:\n- 既存の `_fetch_*_items()` パターンに従う\n- `feedparser` ライブラリを利用（既存のRSS/Hatena取得と同じ）\n- RSS（`.rss`）とAtom（`.atom`）の両方に対応\n- エラーハンドリングで他のソースに影響を与えない\n\n### 3. SpeakerDeck PDF取得ハンドラー\n\n#### 新規ファイル: `app/services/speakerdeck_handler.py`\n\n```python\n\"\"\"SpeakerDeck specific handlers for PDF download and metadata.\"\"\"\nimport logging\nimport httpx\nfrom pathlib import Path\nfrom typing import Optional, Dict, Any\nfrom urllib.parse import urlparse, quote\nimport hashlib\nimport uuid\n\nlogger = logging.getLogger(__name__)\n\nclass SpeakerDeckHandler:\n    \"\"\"Handle SpeakerDeck-specific operations.\"\"\"\n    \n    OEMBED_API = \"https://speakerdeck.com/oembed.json\"\n    TIMEOUT = 30.0\n    MAX_FILE_SIZE = 100 * 1024 * 1024  # 100MB\n    \n    @staticmethod\n    def is_speakerdeck_url(url: str) -> bool:\n        \"\"\"Check if URL is from SpeakerDeck.\"\"\"\n        if not url:\n            return False\n        parsed = urlparse(url)\n        return parsed.netloc in (\"speakerdeck.com\", \"www.speakerdeck.com\")\n    \n    @staticmethod\n    def get_pdf_url(presentation_url: str) -> Optional[str]:\n        \"\"\"Get PDF download URL from SpeakerDeck presentation URL.\n        \n        Uses oEmbed API: https://speakerdeck.com/oembed.json?url=<presentation_url>\n        \n        Returns:\n            PDF download URL or None if not found/error\n        \"\"\"\n        if not SpeakerDeckHandler.is_speakerdeck_url(presentation_url):\n            return None\n        \n        try:\n            with httpx.Client(timeout=SpeakerDeckHandler.TIMEOUT) as client:\n                params = {\"url\": presentation_url}\n                response = client.get(SpeakerDeckHandler.OEMBED_API, params=params)\n                response.raise_for_status()\n                data = response.json()\n                \n                # oEmbed response may not include direct PDF link\n                # Extract from HTML or use alternative approach\n                # SpeakerDeck PDFs are typically at: \n                # https://speakerd.s3.amazonaws.com/presentations/<id>/<slug>.pdf\n                \n                # Try to extract from HTML or metadata\n                # For now, log and return None if not directly available\n                # This may require scraping the presentation page\n                \n                logger.debug(f\"oEmbed response: {data}\")\n                \n                # Alternative: scrape presentation page\n                return SpeakerDeckHandler._extract_pdf_from_page(presentation_url, client)\n        \n        except Exception as e:\n            logger.error(f\"Failed to get PDF URL for {presentation_url}: {e}\")\n            return None\n    \n    @staticmethod\n    def _extract_pdf_from_page(presentation_url: str, client: httpx.Client) -> Optional[str]:\n        \"\"\"Extract PDF URL by scraping the presentation page.\n        \n        SpeakerDeck embeds PDF link in meta tags or download button.\n        \"\"\"\n        try:\n            response = client.get(presentation_url)\n            response.raise_for_status()\n            html = response.text\n            \n            # Look for PDF link patterns\n            import re\n            \n            # Pattern 1: Direct PDF link in meta tags\n            match = re.search(r'<meta[^>]+property=[\"\\']og:url[\"\\'][^>]+content=[\"\\']([^\"\\']+\\.pdf)[\"\\']', html, re.I)\n            if match:\n                return match.group(1)\n            \n            # Pattern 2: Download button or link\n            match = re.search(r'href=[\"\\']([^\"\\']*speakerd\\.s3\\.amazonaws\\.com[^\"\\']*\\.pdf)[\"\\']', html, re.I)\n            if match:\n                return match.group(1)\n            \n            # Pattern 3: JSON-LD or data attributes\n            match = re.search(r'data-pdf-url=[\"\\']([^\"\\']+)[\"\\']', html, re.I)\n            if match:\n                return match.group(1)\n            \n            logger.warning(f\"Could not extract PDF URL from {presentation_url}\")\n            return None\n        \n        except Exception as e:\n            logger.error(f\"Failed to scrape PDF URL from {presentation_url}: {e}\")\n            return None\n    \n    @staticmethod\n    def download_pdf(pdf_url: str, document_id: str) -> Optional[str]:\n        \"\"\"Download PDF and save to local storage.\n        \n        Args:\n            pdf_url: URL of the PDF file\n            document_id: Document UUID for filename\n        \n        Returns:\n            Relative path to saved PDF or None if failed\n        \"\"\"\n        if not pdf_url:\n            return None\n        \n        # Create directory\n        pdf_dir = Path(\"data/assets/pdfs/speakerdeck\")\n        pdf_dir.mkdir(parents=True, exist_ok=True)\n        \n        # Generate filename\n        filename = f\"{document_id}.pdf\"\n        file_path = pdf_dir / filename\n        relative_path = f\"assets/pdfs/speakerdeck/{filename}\"\n        \n        try:\n            with httpx.Client(timeout=SpeakerDeckHandler.TIMEOUT) as client:\n                # Stream download to handle large files\n                with client.stream(\"GET\", pdf_url) as response:\n                    response.raise_for_status()\n                    \n                    # Check content type\n                    content_type = response.headers.get(\"content-type\", \"\")\n                    if \"pdf\" not in content_type.lower():\n                        logger.warning(f\"Unexpected content-type for PDF: {content_type}\")\n                    \n                    # Check file size\n                    content_length = response.headers.get(\"content-length\")\n                    if content_length and int(content_length) > SpeakerDeckHandler.MAX_FILE_SIZE:\n                        logger.error(f\"PDF file too large: {content_length} bytes\")\n                        return None\n                    \n                    # Save to file\n                    with open(file_path, \"wb\") as f:\n                        for chunk in response.iter_bytes(chunk_size=8192):\n                            f.write(chunk)\n                \n                logger.info(f\"Downloaded PDF: {relative_path}\")\n                return relative_path\n        \n        except Exception as e:\n            logger.error(f\"Failed to download PDF from {pdf_url}: {e}\")\n            # Clean up partial file\n            if file_path.exists():\n                file_path.unlink()\n            return None\n```\n\n**設計判断**:\n- クラスベースの設計で関連機能をカプセル化\n- oEmbed APIを第一の手段として利用\n- フォールバックとして HTML スクレイピング（SpeakerDeckのHTML構造に依存）\n- ストリーミングダウンロードで大容量PDFに対応\n- ファイルサイズ制限とタイムアウトでリソース保護\n- エラー時の部分ファイルクリーンアップ\n\n### 4. Ingestionパイプラインの拡張\n\n#### `app/services/ingest_worker.py` の `_insert_document_from_url()` を拡張\n\n既存の関数に SpeakerDeck PDF 処理を統合：\n\n```python\ndef _insert_document_from_url(db, url: str, source_name: str = \"manual\"):\n    \"\"\"Extract content from URL and insert into database.\n    \n    ... 既存docstring ...\n    \"\"\"\n    # ... 既存のextraction処理 ...\n    \n    # Insert document\n    doc_id = _insert_document_if_new(db, doc, source_name)\n    \n    if doc_id:\n        # SpeakerDeck PDF handling (新規追加)\n        if SpeakerDeckHandler.is_speakerdeck_url(url):\n            try:\n                logger.info(f\"Detected SpeakerDeck URL, attempting PDF download: {url}\")\n                pdf_url = SpeakerDeckHandler.get_pdf_url(url)\n                \n                if pdf_url:\n                    pdf_path = SpeakerDeckHandler.download_pdf(pdf_url, doc_id)\n                    \n                    if pdf_path:\n                        # Update document with pdf_path\n                        db.execute(\n                            text(\"UPDATE documents SET pdf_path = :pdf_path WHERE id = :id\"),\n                            {\"pdf_path\": pdf_path, \"id\": doc_id}\n                        )\n                        db.commit()\n                        logger.info(f\"Saved PDF for document {doc_id}: {pdf_path}\")\n                    else:\n                        logger.warning(f\"Failed to download PDF for {url}\")\n                else:\n                    logger.warning(f\"Could not extract PDF URL from {url}\")\n            \n            except Exception as e:\n                logger.error(f\"SpeakerDeck PDF processing failed for {url}: {e}\")\n                # Don't fail document insertion on PDF error\n        \n        # ... 既存のpostprocess処理 ...\n    \n    return doc_id\n```\n\n**設計判断**:\n- PDF取得はドキュメント挿入後の追加処理（失敗してもドキュメントは保存される）\n- トランザクション管理: PDF path の更新は別のUPDATE文で実行\n- 非同期処理は避け、同期的にPDFをダウンロード（将来的な最適化候補）\n- エラーログは残すが、処理は継続\n\n### 5. PDFダウンロードAPIエンドポイント\n\n#### 新規ファイル: `app/api/routes/documents.py` に追加\n\n```python\nfrom fastapi import APIRouter, HTTPException, Depends\nfrom fastapi.responses import FileResponse\nfrom sqlalchemy import text\nfrom pathlib import Path\nfrom app.core.database import get_db\n\nrouter = APIRouter(prefix=\"/api/documents\", tags=[\"documents\"])\n\n@router.get(\"/{document_id}/pdf\")\nasync def download_pdf(document_id: str, db=Depends(get_db)):\n    \"\"\"Download PDF file for a document.\n    \n    Args:\n        document_id: Document UUID\n    \n    Returns:\n        PDF file as FileResponse\n    \n    Raises:\n        404: Document not found or PDF not available\n        500: File system error\n    \"\"\"\n    # Get document from database\n    result = db.execute(\n        text(\"SELECT id, title, pdf_path FROM documents WHERE id = :id\"),\n        {\"id\": document_id}\n    ).fetchone()\n    \n    if not result:\n        raise HTTPException(status_code=404, detail=\"Document not found\")\n    \n    doc = dict(result._mapping)\n    pdf_path = doc.get(\"pdf_path\")\n    \n    if not pdf_path:\n        raise HTTPException(status_code=404, detail=\"PDF not available for this document\")\n    \n    # Construct full file path\n    full_path = Path(\"data\") / pdf_path\n    \n    # Security: validate path is within data directory\n    try:\n        full_path = full_path.resolve()\n        data_dir = Path(\"data\").resolve()\n        if not str(full_path).startswith(str(data_dir)):\n            raise HTTPException(status_code=403, detail=\"Invalid file path\")\n    except Exception:\n        raise HTTPException(status_code=403, detail=\"Invalid file path\")\n    \n    # Check file exists\n    if not full_path.exists() or not full_path.is_file():\n        raise HTTPException(status_code=404, detail=\"PDF file not found on disk\")\n    \n    # Generate safe filename for download\n    title = doc.get(\"title\", \"document\")\n    # Sanitize title for filename\n    safe_title = \"\".join(c for c in title if c.isalnum() or c in (' ', '-', '_')).strip()\n    safe_title = safe_title[:100]  # Limit length\n    filename = f\"{safe_title}.pdf\" if safe_title else f\"{document_id}.pdf\"\n    \n    # Return file\n    return FileResponse(\n        path=str(full_path),\n        media_type=\"application/pdf\",\n        filename=filename,\n        headers={\n            \"Content-Disposition\": f'attachment; filename=\"{filename}\"'\n        }\n    )\n```\n\n#### `app/main.py` にルーターを登録\n\n```python\nfrom app.api.routes import documents\n\napp.include_router(documents.router)\n```\n\n**設計判断**:\n- RESTful APIパターン: `GET /api/documents/{id}/pdf`\n- セキュリティ: パストラバーサル攻撃を防ぐための厳密なパス検証\n- ファイル名のサニタイゼーション: ドキュメントタイトルから安全なファイル名を生成\n- `FileResponse` を使用した効率的なファイル転送\n- `Content-Disposition: attachment` でダウンロードを強制\n\n### 6. UIコンポーネント\n\n#### `app/templates/partials/document_card.html` にPDFダウンロードボタンを追加\n\n```html\n<!-- 既存の「元記事」ボタンの後に追加 -->\n<div class=\"mt-1 text-xs text-gray-400 truncate flex items-center gap-2\">\n    {% if document.source %}\n        <span class=\"pill nowrap-tag inline-flex items-center h-6 px-2 text-xs\">\n            {{ '手動' if document.source == 'manual' else document.source }}\n        </span>\n    {% endif %}\n    \n    {% if document.domain %}\n        <span class=\"inline-block truncate max-w-[12rem]\">{{ document.domain }}</span>\n    {% endif %}\n    \n    {% if document.url %}\n        <a href=\"{{ document.url }}\" target=\"_blank\" rel=\"noopener noreferrer\" \n           class=\"pill nowrap-tag inline-flex items-center h-6 px-2 text-xs bg-mist/80 text-graphite border border-mist\">\n            <i data-lucide=\"external-link\" class=\"w-4 h-4 mr-2\"></i>\n            元記事\n        </a>\n    {% endif %}\n    \n    <!-- 新規追加: PDFダウンロードボタン -->\n    {% if document.pdf_path %}\n        <a href=\"/api/documents/{{ document.id }}/pdf\" \n           download\n           class=\"pill nowrap-tag inline-flex items-center h-6 px-2 text-xs bg-red-50 text-red-600 border border-red-200 hover:bg-red-100 transition-colors\"\n           title=\"PDFをダウンロード\">\n            <i data-lucide=\"file-down\" class=\"w-4 h-4 mr-1\"></i>\n            PDF\n        </a>\n    {% endif %}\n    \n    <a href=\"/documents/{{ document.id }}\" \n       class=\"text-xs bg-emerald text-white px-3 py-1 rounded-md hover:bg-emerald/90 ml-2\">\n        詳細を見る\n    </a>\n</div>\n```\n\n**設計判断**:\n- 条件付き表示: `{% if document.pdf_path %}` でPDFが存在する場合のみ表示\n- アイコン: `file-down` (Lucide Icons) でダウンロードアクションを明示\n- カラー: 赤系統でPDFファイルを視覚的に識別\n- `download` 属性でブラウザにダウンロードを指示\n- ツールチップ（title属性）でアクションを説明\n\n#### ドキュメント詳細ページにも追加\n\n`app/templates/document_detail.html` にも同様のボタンを追加：\n\n```html\n<!-- ヘッダーセクションのアクションボタン群に追加 -->\n{% if document.pdf_path %}\n    <a href=\"/api/documents/{{ document.id }}/pdf\" \n       download\n       class=\"inline-flex items-center px-4 py-2 bg-red-50 text-red-600 border border-red-200 rounded-md hover:bg-red-100 transition-colors\">\n        <i data-lucide=\"file-down\" class=\"w-5 h-5 mr-2\"></i>\n        PDFをダウンロード\n    </a>\n{% endif %}\n```\n\n### 7. 管理画面での表示\n\n#### `app/templates/admin/documents.html` (存在する場合)\n\nドキュメント一覧に PDF 状態を表示：\n\n```html\n<table class=\"min-w-full\">\n    <thead>\n        <tr>\n            <!-- 既存カラム -->\n            <th>タイトル</th>\n            <th>ドメイン</th>\n            <th>作成日</th>\n            <!-- 新規追加 -->\n            <th>PDF</th>\n        </tr>\n    </thead>\n    <tbody>\n        {% for doc in documents %}\n        <tr>\n            <!-- 既存データ -->\n            <td>{{ doc.title }}</td>\n            <td>{{ doc.domain }}</td>\n            <td>{{ doc.created_at|to_jst('%Y-%m-%d') }}</td>\n            <!-- 新規追加 -->\n            <td class=\"text-center\">\n                {% if doc.pdf_path %}\n                    <a href=\"/api/documents/{{ doc.id }}/pdf\" \n                       class=\"text-red-600 hover:text-red-800\" \n                       title=\"PDFダウンロード\">\n                        <i data-lucide=\"file-check\" class=\"w-5 h-5\"></i>\n                    </a>\n                {% else %}\n                    <span class=\"text-gray-300\">\n                        <i data-lucide=\"file-x\" class=\"w-5 h-5\"></i>\n                    </span>\n                {% endif %}\n            </td>\n        </tr>\n        {% endfor %}\n    </tbody>\n</table>\n```\n\n## データフロー\n\n### 1. フィード登録フロー\n```\nユーザー入力（管理画面）\n  → POST /api/admin/sources\n    → DB: sources テーブルに登録\n      → cron スケジュール設定\n```\n\n### 2. 自動取得フロー\n```\nScheduler (cron)\n  → trigger_fetch_for_source(source_id)\n    → _fetch_speakerdeck_items(config)\n      → feedparser.parse(feed_url)\n        → [エントリリスト]\n          → _insert_document_from_url(url)\n            → extractor.extract_from_url()\n            → _insert_document_if_new()\n              → [SpeakerDeck検出]\n                → SpeakerDeckHandler.get_pdf_url()\n                → SpeakerDeckHandler.download_pdf()\n                → UPDATE documents SET pdf_path\n```\n\n### 3. PDFダウンロードフロー\n```\nユーザークリック（UIボタン）\n  → GET /api/documents/{id}/pdf\n    → DB: pdf_path 取得\n      → File System: PDFファイル読み込み\n        → FileResponse (HTTP)\n          → ブラウザ: ダウンロード開始\n```\n\n## エラーハンドリング\n\n### 1. フィード取得エラー\n- **ネットワークエラー**: ログに記録、次回スケジュールで再試行\n- **フォーマットエラー**: feedparser が処理、エラーエントリはスキップ\n- **認証エラー**: 404/403レスポンス時はログに記録、ソースを無効化推奨\n\n### 2. PDF取得エラー\n- **URL抽出失敗**: 警告ログ、ドキュメントは登録（pdf_path = NULL）\n- **ダウンロード失敗**: エラーログ、部分ファイル削除、pdf_path = NULL\n- **タイムアウト**: 30秒で中断、エラーログ\n- **ファイルサイズ超過**: ダウンロード中止、エラーログ\n\n### 3. PDFダウンロードエラー（エンドポイント）\n- **ドキュメント不存在**: 404 Not Found\n- **PDF未保存**: 404 Not Found (詳細メッセージ付き)\n- **ファイル不存在**: 404 Not Found (ディスク上にファイルがない)\n- **パス不正**: 403 Forbidden (セキュリティエラー)\n\n## セキュリティ考慮事項\n\n### 1. パストラバーサル対策\n```python\n# 必ず data/ ディレクトリ内に限定\nfull_path = full_path.resolve()\ndata_dir = Path(\"data\").resolve()\nif not str(full_path).startswith(str(data_dir)):\n    raise HTTPException(status_code=403)\n```\n\n### 2. ファイルサイズ制限\n- デフォルト: 100MB\n- 設定で調整可能\n\n### 3. URL検証\n```python\n# SpeakerDeckドメインのみ許可\nif parsed.netloc not in (\"speakerdeck.com\", \"www.speakerdeck.com\"):\n    return None\n```\n\n### 4. ファイル名サニタイゼーション\n```python\n# 英数字とスペース、ハイフン、アンダースコアのみ許可\nsafe_title = \"\".join(c for c in title if c.isalnum() or c in (' ', '-', '_'))\n```\n\n## パフォーマンス最適化\n\n### 1. 非同期処理の検討（将来的）\n- PDF ダウンロードをバックグラウンドタスクに移行\n- Celery や rq を使用したワーカープロセス\n- 現状: 同期処理で実装（シンプルさ優先）\n\n### 2. キャッシュ戦略\n- PDFファイルは永続保存、再ダウンロード不要\n- ブラウザキャッシュヘッダー設定（将来的）\n\n### 3. データベースインデックス\n```sql\nCREATE INDEX idx_documents_pdf_path ON documents(pdf_path) WHERE pdf_path IS NOT NULL;\n```\n\n## テスト戦略\n\n### 1. ユニットテスト\n- `SpeakerDeckHandler.is_speakerdeck_url()`\n- `SpeakerDeckHandler.get_pdf_url()` (モック使用)\n- `SpeakerDeckHandler.download_pdf()` (モック使用)\n- `_fetch_speakerdeck_items()` (feedparserモック)\n\n### 2. 統合テスト\n- フィード登録 → 自動取得 → ドキュメント登録\n- PDF ダウンロード → ファイル保存 → DB更新\n- PDFダウンロードAPIエンドポイント\n\n### 3. E2Eテスト（Playwright）\n- SpeakerDeckソース登録\n- ドキュメントカードでPDFボタン表示確認\n- PDFダウンロードボタンクリック → ファイルダウンロード確認\n\n## 監視・ログ\n\n### ログレベル\n- **INFO**: フィード取得成功、PDF保存成功\n- **WARNING**: PDF URL抽出失敗、ダウンロード失敗（ドキュメントは登録）\n- **ERROR**: ネットワークエラー、ファイルシステムエラー\n\n### メトリクス（将来的）\n- フィード取得成功率\n- PDF保存成功率\n- PDFダウンロード数\n- ストレージ使用量\n\n## 依存関係\n\n### 既存ライブラリ\n- `feedparser`: RSS/Atom解析\n- `httpx`: HTTP通信\n- `Pillow`: サムネイル生成（既存）\n- `FastAPI`: APIフレームワーク\n- `SQLAlchemy`: データベース\n\n### 新規依存関係\nなし（既存ライブラリで実装可能）\n\n## 後方互換性\n\n- 既存ドキュメントは `pdf_path = NULL` で動作継続\n- 既存フィード（qiita, hatena, rss）に影響なし\n- UI: PDFボタンは条件付き表示、既存UIを破壊しない\n- API: 新規エンドポイント追加のみ\n\n## デプロイ手順\n\n1. **マイグレーション実行**\n   ```bash\n   python migrations/apply_migrations.py\n   ```\n\n2. **コード更新**\n   - `app/services/speakerdeck_handler.py` 追加\n   - `app/services/ingest_worker.py` 更新\n   - `app/api/routes/documents.py` 更新\n   - `app/templates/partials/document_card.html` 更新\n\n3. **ディレクトリ作成**\n   ```bash\n   mkdir -p data/assets/pdfs/speakerdeck\n   ```\n\n4. **アプリケーション再起動**\n   ```bash\n   systemctl restart scrap-board\n   # または docker-compose restart\n   ```\n\n5. **動作確認**\n   - SpeakerDeckソース登録\n   - フィード取得実行\n   - PDFダウンロード確認\n\n## 将来の拡張候補\n\n1. **PDFプレビュー機能**\n   - ブラウザ内PDFビューアー統合\n   - サムネイル生成（最初のページ）\n\n2. **バックグラウンド処理**\n   - PDF取得を非同期タスクキューに移行\n   - 再試行ロジック実装\n\n3. **ストレージ管理**\n   - 古いPDFの自動削除\n   - ストレージ使用量アラート\n\n4. **他のスライドサービス対応**\n   - SlideShare\n   - Docswell\n   - Google Slides\n\n5. **PDF分析機能**\n   - OCR（日本語対応）\n   - テキスト抽出・検索\n   - スライド枚数カウント\n",
  "fileStats": {
    "size": 27554,
    "lines": 787,
    "lastModified": "2025-10-04T06:23:24.817Z"
  },
  "comments": []
}